## 项目组织
### workspace

workspace 是一个目录（directory hierachy），在这个目录下有三个子目录

- `src` 放源代码文件
- `pkg` 放编译后的包文件，包文件名字与所在目录一样，注意：名字与 package 无关
- `bin` 放编译后的可执行文件，可执行文件名字与源代码文件名字一样

一个真实的例子：

```
bin/
    hello              # 可执行的命令
    outyet             # 可执行的命令
pkg/
    linux_amd64/
        github/golang/example/
            stringutil.a          # pakcage objects
src/
    github.com/golang/example/
        .git/                     # git repository metadata
        hello/
            hello.go              # command source
        outyet/
            main.go               # command source
            main_test.go          # test source
        stringuitl/
            reverse.go            # package source
            reverse_test.go       # test source
```

### GOPATH

- 一种项目组织管理的方式。直接编译或者运行源码当然更加灵活，但是项目变大的时候不好管理
- GOPATH规定了workspace的目录位置，linux上的默认值是$HOME/go，windows上的默认值是C:\Users\YourName\go
- 可以设置多个GOPATH，[go 多个GOPATH_busai2的专栏-CSDN博客_多个gopath](https://blog.csdn.net/busai2/article/details/83584306)
- `GOPATH` must **not** be the same path as your Go installation
- Import paths：就是在代码中import包时使用的字符串，有base path（repository路径）和 package path 组成。
  - go自带的标准库可以直接使用简短路劲，比如 "fmt" and "net/http"
  - 第三方的包引用或者如果将来想将自己的发布到远程的package，则需要指定base path
    - 此时package path 就是源代码一开始的 `package stringutil`？👉 不是
    - base path可以随意指定，但是一定要和go的标准库的base path能唯一区分
    - 如果使用的base path是 github.com/user，那么在本地的workspace中创建的源码目录的路径就是 `$GOPATH/src/github.com/user`
- `GOPATH`的使用 [How to Write Go Code (with GOPATH) - The Go Programming Language (golang.org)](https://golang.org/doc/gopath_code)
  - 在src目录下直接go build源码还是只在当前目录下生成exe文件。
  - 使用go install 命令会 build 出 exe文件，并将其移动到bin目录中，之后可以直接通过命令行使用
    - 如果go install命令没有指定后面的名字，那么默认以当前目录的最后一个文件名为exe的文件名。比如`$GOPATH/src/github.com/user/`的话，生成的exe文件名就是 user.exe
    - 如果源码中使用到了第三方的包，那么下载后的第三方包会不会保存在`GOPATH`的pkg中？
      - 只使用`GOPATH`的话，貌似不会，只能通过 go get 来将第三方package以源码的形式下载到`GOPATH`的src目录
  - 如果在`GOPATH`之外的目录里的源码执行 go insall 会提示 `go install: no install location for .go files listed on command line (GOBIN not set)`，当然build没问题
  - go build 没有main方法的源码时（即给别的代码调用的，也就是library），不会生成 exe 可执行文件（因为本来就单独执行不了）。会把编译后的结果暂时放在在**`local build cache`**里
    - **local build cache**: 通过`GOCACHE`环境变量来指定位置
  - 对library的引用，无论是网络的第三方package，还是同一个项目中的其他package，都要指定完全的 base path
    - 代码中的package 名字和所在目录的最后一个目录不一样的时候能正常引用吗❓ 👉 [Package Name and Directory/Folder Name in Go (Golang)- Does they need to be the same - Welcome To Golang By Example](https://golangbyexample.com/package-folder-name-golang/)
    - 经过实际的尝试本地（同一个项目内）的package引用，不会在pkg里生成啥东西。感觉本地的同一个项目内的package的相互调用其实就和python的import差不多，直接import就好了，不需要提前下载啥的
    - 教程上给的对远程package的使用是先 go get 源码到 src 目录，然后再向本地package那样使用，不get直接import会咋样？会报错
- pkg目录的作用是啥？
  - [GOPATH · Go语言学习笔记 (zhaohuabing.com)](https://zhaohuabing.com/learning-golang/content/directory/gopath.html)

### 文件的位置关系

go默认安装路径是`C:/go`，项目的构成由源码和编译出来的东西，以及从网络仓库/本地仓库的library构成。

- 源码和编译出来的文件的位置关系？
  - 源码位置可以任意存放，go run直接运行的话不会编译出额外的文件
  - 利用go build编译源码会得到同名的exe文件，默认就在当前目录下生成
    - **那么和GOPATH指定的目录又有啥关系**？
      - GOPATH目录是一种项目组织管理的方式。直接编译运行源码当然更加灵活，但是项目变大的时候不好管理
      - 有更好的代替GOPATH的方式，使用go mod来管理项目

### 运行&编译

- 如何直接执行go源码？
  - 没有引用其他包的情况：go run 源码文件.go
  - 引用了项目内部其他方法or包的情况：go run 源码文件.go
  - 引用了网络仓库第三方包的情况
    - 只用`GOPATH`的情况下，如果不提前go get，build和run都会报错，需要将其get到`GOPATH`的src目录才可以
  - **如何调用同一个目录下的文件中的函数？** 👉 `go run .` 或 `go run main.go test.go`
- 有其他包引用时如何作依赖管理？
  - 利用Go mod，GOPATH貌似没有依赖管理的功能

### [Go mod](https://golang.org/ref/mod)

管理Go项目依赖用的，mod的全称是Modules

使用：

- [Using Go Modules - The Go Blog (golang.org)](https://blog.golang.org/using-go-modules)
- [告别GOPATH，快速使用 go mod（Golang包管理工具） - 简书 (jianshu.com)](https://www.jianshu.com/p/bbed916d16ea)
- [go mod使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/760c97ff644c)

大致的使用过程就是：

- 不需要非得把项目放到GOPATH指定目录下，你可以在你磁盘的任何位置新建一个项目，然后使用`go mod init 名字`来初始化一个`go.mod`文件。
- 运行了包含第三方包的go程序后会在当前目录下多出一个文件 `go.sum`，用来记录依赖的项目的版本的锁定
- 可以很方便的哦才能够go mod管理模式迁移到`GOPATH`的项目管理模式
  - 只需要把这个项目移到GOPATH环境变量包含的任意一个目录下面的src目录里，就可以启用GOPATH模式了（前提是 GO111MODULE 这个环境变量的值必须是auto 或 off）
- 使用`go mod`命令管理包

`go.mod`文件中使用4个命令来配置依赖

### Go环境变量
- `GOPATH`：规定了workspace的目录位置
- `GOROOT`：go的安装目录
- `GOCACHE`：指定build的cache存放的目录位置

## Go cmd

- go run
- go build 
- go install 👉 于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包
  - install和build的不同在于，install了之后可以在命令行像使用普通命令一样直接执行exe程序
  - 参数和build共通
- go test：使用go自带的轻量级测试框架测试代码
  - 使用例：go test github.com/user/stringutil
- go get：获得远程仓库的源码，注意这个
  - 使用例：go get github.com/golang/example/hello
  - If the specified package is not present in a workspace, `go get` will place it inside the first workspace specified by `GOPATH`
  - 这个命令无论在哪里执行，都会将下载的源码放到`GOPATH`指定的第一个workspace中的`src`目中去
  - [go get命令——一键获取代码、编译并安装 (biancheng.net)](http://c.biancheng.net/view/123.html)
- go mod 比较常用的三个命令
  - init：初始化新的go.mod文件
  - tidy：拉取缺少的模块，移除不用的模块
  - edit：编辑go.mod

## 变量和常量

### iota

- 特殊常量，可以认为是一个可以被编译器修改的常量
- iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。
- 可用作枚举值

## 数据结构

### 数组和切片

### 哈希表

### 结构体

### 字符串

## 函数&接口

### 函数

### 空接口

### 静态类型和动态类型

### 类型断言

### 反射

- [Go语言反射（reflection）简述 (biancheng.net)](http://c.biancheng.net/view/4407.html)

- 反射是指在程序运行期对程序本身进行访问和修改的能力
- 反射是把双刃剑，功能强大但代码可读性并不理想，若非必要并不推荐使用反射

- 通过`reflect`包来实现反射机制
- `reflect.TypeOf()` 能获取类型信息，`reflect.ValueOf()` 能获取数据的运行时表示
- 类型和种类

## 关键字

### type

- 类型别名

  ```go
  type NewInt int
  ```

### go

- `go func(){}()`，开启协程，让函数在另一个协程中执行

### make&new

- 都可以初始化一个结构

- `make` 的作用是初始化内置的数据结构，make 只能用于 slice,map,channel

  ```go
  slice := make([]int, 0, 100)	
  hash := make(map[int]bool, 10)	
  ch := make(chan int, 5)			
  ```

- make(T, ...) always returns type T, whereas new(T, ...) always returns type *T

- `new` 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针

  - 只能接收类型作为参数然后返回一个指向该类型的指针

  ```go
  i := new(int)
  // 上面的初始化和下面的初始化等价
  var v int
  i := &v
  ```

### defer

### panic&recover

## 并发

### 协程

### 通道

## 网络通信

### tcp&udp

### client&server

### context

## 资料

- [34. 图解 Go 语言：静态类型与动态类型 - SegmentFault 思否](https://segmentfault.com/a/1190000022931452)
- [Interfaces in Golang - GeeksforGeeks](https://www.geeksforgeeks.org/interfaces-in-golang/)
- [Go 语言中的 make 和 new | Go 语言设计与实现 (draveness.me)](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/)
- [理解 Go defer | 三月沙 (sanyuesha.com)](https://sanyuesha.com/2017/07/23/go-defer/)
- [go defer,panic,recover详解 go 的异常处理 - 简书 (jianshu.com)](https://www.jianshu.com/p/63e3d57f285f)

## issue

**go run —> Don't communicate by sharing memory**



